import { MEDIA_BUCKET, OWNER_ACCOUNT_ID } from "@/lib/constants";
import { ensureOwnerAccount } from "@/lib/supabase/owner";
import { createServiceSupabaseClient } from "@/lib/supabase/service";
import { isSchemaMissingError } from "@/lib/supabase/errors";

interface PlannerItem {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  scheduledFor: string;
  campaignName: string;
  status: "draft" | "scheduled" | "publishing" | "posted" | "failed";
  autoGenerated: boolean;
}

interface PlannerActivity {
  id: string;
  message: string;
  timestamp: string;
  level: "info" | "warning" | "error";
  category?: string | null;
  metadata?: Record<string, unknown> | null;
  readAt?: string | null;
}

export interface PlannerOverview {
  items: PlannerItem[];
  activity: PlannerActivity[];
}

export interface PlannerContentDetail {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  status: PlannerItem["status"];
  scheduledFor: string | null;
  body: string;
  mediaIds: string[];
  campaign: {
    id: string | null;
    name: string | null;
  } | null;
  autoGenerated: boolean;
  promptContext: Record<string, unknown> | null;
  media: Array<{
    id: string;
    url: string;
    mediaType: "image" | "video";
    fileName: string | null;
  }>;
}

type ContentRow = {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  scheduled_for: string | null;
  status: PlannerItem["status"];
  auto_generated: boolean | null;
  campaigns: {
    name: string | null;
  } | null;
};

type ContentDetailRow = {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  scheduled_for: string | null;
  status: PlannerItem["status"];
  auto_generated: boolean | null;
  prompt_context: Record<string, unknown> | null;
  campaigns: {
    id: string | null;
    name: string | null;
  } | null;
  content_variants: Array<{
    body: string | null;
    media_ids: string[] | null;
  }> | null;
};

type MediaAssetRow = {
  id: string;
  file_name: string | null;
  media_type: "image" | "video";
  storage_path: string;
};

type NotificationRow = {
  id: string;
  message: string;
  category: string | null;
  metadata: Record<string, unknown> | null;
  read_at: string | null;
  created_at: string;
};

const EMPTY_OVERVIEW: PlannerOverview = { items: [], activity: [] };

export async function getPlannerOverview(): Promise<PlannerOverview> {
  await ensureOwnerAccount();
  const supabase = createServiceSupabaseClient();

  const now = new Date();
  const nowIso = now.toISOString();
  const horizonIso = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString();

  try {
    const { data: contentData, error: contentError } = await supabase
      .from("content_items")
      .select("id, platform, scheduled_for, status, auto_generated, campaigns(name)")
      .eq("account_id", OWNER_ACCOUNT_ID)
      .gte("scheduled_for", nowIso)
      .lte("scheduled_for", horizonIso)
      .order("scheduled_for", { ascending: true })
      .limit(35)
      .returns<ContentRow[]>();

    if (contentError) {
      if (isSchemaMissingError(contentError)) {
        return EMPTY_OVERVIEW;
      }
      throw contentError;
    }

    const { data: activityData, error: activityError } = await supabase
      .from("notifications")
      .select("id, message, category, metadata, read_at, created_at")
      .eq("account_id", OWNER_ACCOUNT_ID)
      .is("read_at", null)
      .order("created_at", { ascending: false })
      .limit(6)
      .returns<NotificationRow[]>();

    if (activityError) {
      if (isSchemaMissingError(activityError)) {
        return EMPTY_OVERVIEW;
      }
      throw activityError;
    }

    const contentRows = contentData ?? [];
    const activityRows = activityData ?? [];

    const items: PlannerItem[] = contentRows.map((row) => ({
      id: row.id,
      platform: row.platform,
      scheduledFor: row.scheduled_for ?? nowIso,
      campaignName: row.campaigns?.name ?? "Untitled campaign",
      status: row.status,
      autoGenerated: Boolean(row.auto_generated),
    }));

    const activity: PlannerActivity[] = activityRows.map((row) => ({
      id: row.id,
      message: row.message,
      timestamp: row.created_at,
      level: mapCategoryToLevel(row.category),
      category: row.category,
      metadata: row.metadata,
      readAt: row.read_at,
    }));

    return { items, activity };
  } catch (error) {
    if (isSchemaMissingError(error)) {
      return EMPTY_OVERVIEW;
    }
    throw error;
  }
}

export async function getPlannerContentDetail(contentId: string): Promise<PlannerContentDetail | null> {
  await ensureOwnerAccount();
  const supabase = createServiceSupabaseClient();

  try {
    const { data, error } = await supabase
      .from("content_items")
      .select(
        "id, platform, scheduled_for, status, auto_generated, prompt_context, campaigns(id, name), content_variants(body, media_ids)"
      )
      .eq("id", contentId)
      .eq("account_id", OWNER_ACCOUNT_ID)
      .maybeSingle<ContentDetailRow>();

    if (error) {
      if (isSchemaMissingError(error)) {
        return null;
      }
      throw error;
    }

    if (!data) return null;

    const variant = data.content_variants?.[0];
    const mediaIds = variant?.media_ids ?? [];
    const media = await loadMediaPreviews({ supabase, mediaIds });

    return {
      id: data.id,
      platform: data.platform,
      status: data.status as PlannerItem["status"],
      scheduledFor: data.scheduled_for,
      body: variant?.body ?? "",
      mediaIds,
      campaign: data.campaigns ? { id: data.campaigns.id ?? null, name: data.campaigns.name ?? null } : null,
      autoGenerated: Boolean(data.auto_generated),
      promptContext: (data.prompt_context as Record<string, unknown> | null) ?? null,
      media,
    };
  } catch (error) {
    if (isSchemaMissingError(error)) {
      return null;
    }
    throw error;
  }
}

async function loadMediaPreviews({
  supabase,
  mediaIds,
}: {
  supabase: ReturnType<typeof createServiceSupabaseClient>;
  mediaIds: string[];
}): Promise<PlannerContentDetail["media"]> {
  if (!mediaIds.length) return [];

  const { data: mediaRows, error } = await supabase
    .from("media_assets")
    .select("id, file_name, media_type, storage_path")
    .in("id", mediaIds)
    .returns<MediaAssetRow[]>();

  if (error) {
    console.error("[planner] failed to load media assets", error);
    return [];
  }

  const rows = mediaRows ?? [];
  if (!rows.length) {
    return [];
  }

  const relativePaths = Array.from(
    new Set(rows.map((row) => normaliseStoragePath(row.storage_path))),
  );

  const { data: signedUrls, error: signedError } = await supabase.storage
    .from(MEDIA_BUCKET)
    .createSignedUrls(relativePaths, 600);

  if (signedError) {
    console.error("[planner] failed to sign media asset urls", signedError);
    return [];
  }

  const urlMap = new Map<string, string>();
  for (const entry of signedUrls ?? []) {
    if (!entry.path) continue;
    if (!entry.error && entry.signedUrl) {
      urlMap.set(entry.path, entry.signedUrl);
    }
  }

  return rows
    .map<PlannerContentDetail["media"][number] | null>((row) => {
      const path = normaliseStoragePath(row.storage_path);
      const url = urlMap.get(path);
      if (!url) return null;
      return {
        id: row.id,
        url,
        mediaType: row.media_type,
        fileName: row.file_name ?? null,
      };
    })
    .filter((item): item is PlannerContentDetail["media"][number] => Boolean(item));
}

function normaliseStoragePath(path: string) {
  if (path.startsWith(`${MEDIA_BUCKET}/`)) {
    return path.slice(MEDIA_BUCKET.length + 1);
  }
  return path;
}

export function mapCategoryToLevel(category: string | null): PlannerActivity["level"] {
  if (!category) return "info";
  switch (category) {
    case "publish_failed":
    case "connection_needs_action":
      return "error";
    case "publish_retry":
    case "connection_metadata_updated":
    case "connection_reconnected":
      return "warning";
    default: {
      const lower = category.toLowerCase();
      if (lower.includes("error")) return "error";
      if (lower.includes("warning") || lower.includes("expiring")) {
        return "warning";
      }
      return "info";
    }
  }
}
