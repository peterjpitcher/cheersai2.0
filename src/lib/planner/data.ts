import type { SupabaseClient } from "@supabase/supabase-js";
import { requireAuthContext } from "@/lib/auth/server";
import { MEDIA_BUCKET } from "@/lib/constants";
import { isSchemaMissingError } from "@/lib/supabase/errors";
import { resolvePreviewCandidates, type PreviewCandidate } from "@/lib/library/data";

type ContentPlacement = "feed" | "story";

interface PlannerItem {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  placement: ContentPlacement;
  scheduledFor: string;
  campaignName: string;
  status: "draft" | "scheduled" | "queued" | "publishing" | "posted" | "failed";
  autoGenerated: boolean;
  mediaPreview?: {
    url: string;
    mediaType: "image" | "video";
  } | null;
}

export interface TrashedPlannerItem {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  placement: ContentPlacement;
  status: PlannerItem["status"];
  scheduledFor: string | null;
  deletedAt: string;
  campaignName: string | null;
  autoGenerated: boolean;
  mediaPreview?: {
    url: string;
    mediaType: "image" | "video";
    fileName: string | null;
  } | null;
  bodyPreview: string | null;
}

interface PlannerActivity {
  id: string;
  message: string;
  timestamp: string;
  level: "info" | "warning" | "error";
  category?: string | null;
  metadata?: Record<string, unknown> | null;
  readAt?: string | null;
}

export interface PlannerOverview {
  items: PlannerItem[];
  activity: PlannerActivity[];
  trash: TrashedPlannerItem[];
}

export interface PlannerContentDetail {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  placement: ContentPlacement;
  status: PlannerItem["status"];
  scheduledFor: string | null;
  body: string;
  mediaIds: string[];
  campaign: {
    id: string | null;
    name: string | null;
  } | null;
  autoGenerated: boolean;
  promptContext: Record<string, unknown> | null;
  media: Array<{
    id: string;
    url: string;
    mediaType: "image" | "video";
    fileName: string | null;
  }>;
  lastError: string | null;
  lastAttemptedAt: string | null;
  providerResponse: Record<string, unknown> | null;
}

type ContentVariantRow = {
  media_ids: string[] | null;
  body?: string | null;
};

type ContentRow = {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  placement: ContentPlacement;
  scheduled_for: string | null;
  status: PlannerItem["status"];
  auto_generated: boolean | null;
  campaigns: {
    name: string | null;
  } | null;
  content_variants: ContentVariantRow[] | ContentVariantRow | null;
};

type ContentDetailVariantRow = {
  body: string | null;
  media_ids: string[] | null;
};

type ContentDetailRow = {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  placement: ContentPlacement;
  scheduled_for: string | null;
  status: PlannerItem["status"];
  auto_generated: boolean | null;
  prompt_context: Record<string, unknown> | null;
  campaigns: {
    id: string | null;
    name: string | null;
  } | null;
  content_variants: ContentDetailVariantRow[] | ContentDetailVariantRow | null;
  publish_jobs: ContentPublishJobRow[] | ContentPublishJobRow | null;
};

type TrashedContentRow = {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  placement: ContentPlacement;
  status: PlannerItem["status"];
  auto_generated: boolean | null;
  scheduled_for: string | null;
  deleted_at: string;
  campaigns: {
    name: string | null;
  } | null;
  content_variants: ContentVariantRow[] | ContentVariantRow | null;
};

type ContentPublishJobRow = {
  last_error: string | null;
  status: string | null;
  attempt: number | null;
  updated_at: string | null;
  placement?: ContentPlacement | null;
  provider_response?: Record<string, unknown> | null;
};

type MediaAssetRow = {
  id: string;
  file_name: string | null;
  media_type: "image" | "video";
  storage_path: string;
  derived_variants?: Record<string, string> | null;
};

type ContentPreviewRef = {
  assetId: string;
  placement: ContentPlacement;
};

type ContentMediaPreview = {
  url: string;
  mediaType: "image" | "video";
  fileName: string | null;
};

type NotificationRow = {
  id: string;
  message: string;
  category: string | null;
  metadata: Record<string, unknown> | null;
  read_at: string | null;
  created_at: string;
};

function normaliseVariants<T extends { media_ids: string[] | null }>(
  collection: T[] | T | null | undefined,
): T[] {
  if (!collection) return [];
  return Array.isArray(collection) ? collection : [collection];
}

const EMPTY_OVERVIEW: PlannerOverview = { items: [], activity: [], trash: [] };

interface PlannerOverviewOptions {
  rangeStart?: Date;
  rangeEnd?: Date;
  includeItems?: boolean;
  includeActivity?: boolean;
  includeTrash?: boolean;
  activityLimit?: number;
  unreadActivityOnly?: boolean;
}

interface PlannerActivityOptions {
  limit?: number;
  unreadOnly?: boolean;
}

export async function getPlannerOverview(options: PlannerOverviewOptions = {}): Promise<PlannerOverview> {
  const {
    rangeStart,
    rangeEnd,
    includeItems = true,
    includeActivity = true,
    includeTrash = true,
    activityLimit,
    unreadActivityOnly = true,
  } = options;

  const { supabase, accountId } = await requireAuthContext();

  let startIso: string | null = null;
  let endIso: string | null = null;
  let fallbackScheduledIso = new Date().toISOString();

  if (includeItems) {
    const now = new Date();
    const defaultStart = rangeStart ?? now;
    const defaultEnd = rangeEnd ?? new Date(defaultStart.getTime() + 7 * 24 * 60 * 60 * 1000);

    const start = defaultStart <= defaultEnd ? defaultStart : defaultEnd;
    const end = defaultEnd >= defaultStart ? defaultEnd : defaultStart;

    startIso = start.toISOString();
    endIso = end.toISOString();
    fallbackScheduledIso = startIso ?? fallbackScheduledIso;
  }

  try {
    const contentPromise: Promise<ContentRow[]> = includeItems
      ? loadPlannerContent({
          supabase,
          accountId,
          startIso,
          endIso,
        })
      : Promise.resolve([]);

    const itemsPromise = includeItems
      ? contentPromise.then((contentRows) =>
          buildPlannerItems({
            supabase,
            contentRows,
            fallbackScheduledIso,
          }),
        )
      : Promise.resolve<PlannerItem[]>([]);

    const activityPromise: Promise<PlannerActivity[]> = includeActivity
      ? loadPlannerActivity({
          supabase,
          accountId,
          limit: activityLimit,
          unreadOnly: unreadActivityOnly,
        })
      : Promise.resolve([]);

    const trashPromise: Promise<TrashedPlannerItem[]> = includeTrash
      ? loadTrashedPlannerContent({
          supabase,
          accountId,
        })
      : Promise.resolve([]);

    const [items, activityRows, trashedItems] = await Promise.all([
      itemsPromise,
      activityPromise,
      trashPromise,
    ]);

    return { items, activity: activityRows, trash: trashedItems };
  } catch (error) {
    if (isSchemaMissingError(error)) {
      return EMPTY_OVERVIEW;
    }
    throw error;
  }
}

export async function getPlannerActivity(options: PlannerActivityOptions = {}): Promise<PlannerActivity[]> {
  const { supabase, accountId } = await requireAuthContext();

  try {
    return await loadPlannerActivity({
      supabase,
      accountId,
      limit: options.limit,
      unreadOnly: options.unreadOnly,
    });
  } catch (error) {
    if (isSchemaMissingError(error)) {
      return [];
    }
    throw error;
  }
}

async function loadPlannerContent({
  supabase,
  accountId,
  startIso,
  endIso,
}: {
  supabase: SupabaseClient;
  accountId: string;
  startIso: string | null;
  endIso: string | null;
}): Promise<ContentRow[]> {
  if (!startIso || !endIso) {
    return [];
  }

  const { data, error } = await supabase
    .from("content_items")
    .select("id, platform, placement, scheduled_for, status, auto_generated, campaigns(name), content_variants(media_ids)")
    .eq("account_id", accountId)
    .is("deleted_at", null)
    .gte("scheduled_for", startIso)
    .lte("scheduled_for", endIso)
    .order("scheduled_for", { ascending: true })
    .limit(500)
    .returns<ContentRow[]>();

  if (error) {
    if (isSchemaMissingError(error)) {
      return [];
    }
    throw error;
  }

  return data ?? [];
}

async function loadPlannerActivity({
  supabase,
  accountId,
  limit,
  unreadOnly = true,
}: {
  supabase: SupabaseClient;
  accountId: string;
  limit?: number;
  unreadOnly?: boolean;
}): Promise<PlannerActivity[]> {
  const finalLimit = typeof limit === "number" && limit > 0 ? limit : 6;

  let query = supabase
    .from("notifications")
    .select("id, message, category, metadata, read_at, created_at")
    .eq("account_id", accountId)
    .order("created_at", { ascending: false })
    .limit(finalLimit);

  if (unreadOnly) {
    query = query.is("read_at", null);
  }

  const { data, error } = await query.returns<NotificationRow[]>();

  if (error) {
    if (isSchemaMissingError(error)) {
      return [];
    }
    throw error;
  }

  const rows = data ?? [];

  return rows.map((row) => ({
    id: row.id,
    message: row.message,
    timestamp: row.created_at,
    level: mapCategoryToLevel(row.category),
    category: row.category,
    metadata: row.metadata,
    readAt: row.read_at,
  }));
}

async function loadTrashedPlannerContent({
  supabase,
  accountId,
}: {
  supabase: SupabaseClient;
  accountId: string;
}): Promise<TrashedPlannerItem[]> {
  const { data, error } = await supabase
    .from("content_items")
    .select("id, platform, placement, status, auto_generated, scheduled_for, deleted_at, campaigns(name), content_variants(body, media_ids)")
    .eq("account_id", accountId)
    .not("deleted_at", "is", null)
    .order("deleted_at", { ascending: false })
    .limit(20)
    .returns<TrashedContentRow[]>();

  if (error) {
    if (isSchemaMissingError(error)) {
      return [];
    }
    throw error;
  }

  const trashedRows = data ?? [];

  const mediaRefs = new Map<string, ContentPreviewRef>();
  for (const row of trashedRows) {
    const variant = normaliseVariants<ContentVariantRow>(row.content_variants)[0];
    const firstMediaId = (variant?.media_ids ?? []).find((id) => Boolean(id));
    if (firstMediaId) {
      mediaRefs.set(row.id, { assetId: firstMediaId, placement: row.placement });
    }
  }

  const mediaPreviewByContent = await loadPrimaryMediaPreviewsByContent({
    supabase,
    mediaRefs,
  });

  return trashedRows.map((row) => {
    const variants = normaliseVariants<ContentVariantRow>(row.content_variants);
    const variant = variants[0];
    const bodySource = variant?.body ?? "";
    const bodyPreview = bodySource ? truncateText(bodySource.replace(/\s+/g, " ").trim(), 200) : null;
    const mediaPreview = mediaPreviewByContent.get(row.id) ?? null;

    return {
      id: row.id,
      platform: row.platform,
      placement: row.placement,
      status: row.status,
      scheduledFor: row.scheduled_for,
      deletedAt: row.deleted_at,
      campaignName: row.campaigns?.name ?? null,
      autoGenerated: Boolean(row.auto_generated),
      mediaPreview,
      bodyPreview,
    };
  });
}

async function buildPlannerItems({
  supabase,
  contentRows,
  fallbackScheduledIso,
}: {
  supabase: SupabaseClient;
  contentRows: ContentRow[];
  fallbackScheduledIso: string;
}): Promise<PlannerItem[]> {
  if (!contentRows.length) {
    return [];
  }

  const mediaRefs = new Map<string, ContentPreviewRef>();

  for (const row of contentRows) {
    const mediaIds = normaliseVariants(row.content_variants).flatMap((variant) => variant.media_ids ?? []);
    const firstMediaId = mediaIds.find((id) => Boolean(id));
    if (firstMediaId) {
      mediaRefs.set(row.id, { assetId: firstMediaId, placement: row.placement });
    }
  }

  const mediaPreviewByContent = await loadPrimaryMediaPreviewsByContent({
    supabase,
    mediaRefs,
  });

  return contentRows.map((row) => ({
    id: row.id,
    platform: row.platform,
    placement: row.placement,
    scheduledFor: row.scheduled_for ?? fallbackScheduledIso,
    campaignName: row.campaigns?.name ?? "Untitled campaign",
    status: row.status ?? "draft",
    autoGenerated: Boolean(row.auto_generated),
    mediaPreview: (() => {
      const preview = mediaPreviewByContent.get(row.id);
      if (!preview) return null;
      return {
        url: preview.url,
        mediaType: preview.mediaType,
      };
    })(),
  }));
}

async function loadPrimaryMediaPreviewsByContent({
  supabase,
  mediaRefs,
}: {
  supabase: SupabaseClient;
  mediaRefs: Map<string, ContentPreviewRef>;
}): Promise<Map<string, ContentMediaPreview>> {
  if (!mediaRefs.size) {
    return new Map();
  }

  const assetIdsToFetch = Array.from(new Set(Array.from(mediaRefs.values()).map((ref) => ref.assetId)));

  const { data: assetRows, error: assetError } = await supabase
    .from("media_assets")
    .select("id, file_name, media_type, storage_path, derived_variants")
    .in("id", assetIdsToFetch)
    .returns<MediaAssetRow[]>();

  if (assetError) {
    if (isSchemaMissingError(assetError)) {
      return new Map();
    }
    throw assetError;
  }

  const previewByAssetId = new Map<
    string,
    {
      mediaType: "image" | "video";
      fileName: string | null;
      candidates: PreviewCandidate[];
    }
  >();
  const uniquePaths = new Set<string>();

  for (const assetRow of assetRows ?? []) {
    const candidates = resolvePreviewCandidates({
      storagePath: assetRow.storage_path,
      derivedVariants: assetRow.derived_variants ?? {},
    });
    previewByAssetId.set(assetRow.id, {
      mediaType: assetRow.media_type === "video" ? "video" : "image",
      fileName: assetRow.file_name ?? null,
      candidates,
    });
    for (const candidate of candidates) {
      uniquePaths.add(candidate.path);
    }
  }

  const urlByPath = new Map<string, string>();
  if (uniquePaths.size) {
    const { data: signedUrls, error: signedError } = await supabase.storage
      .from(MEDIA_BUCKET)
      .createSignedUrls(Array.from(uniquePaths), 600);

    if (signedError) {
      console.error("[planner] failed to sign media previews", signedError);
    } else {
      for (const entry of signedUrls ?? []) {
        if (entry?.path && entry.signedUrl && !entry.error) {
          urlByPath.set(entry.path, entry.signedUrl);
        }
      }
    }
  }

  const previewByContent = new Map<string, ContentMediaPreview>();
  for (const [contentId, ref] of mediaRefs.entries()) {
    const previewInfo = previewByAssetId.get(ref.assetId);
    if (!previewInfo) continue;

    const candidates =
      ref.placement === "story"
        ? [
            ...previewInfo.candidates.filter((candidate) => candidate.shape === "story"),
            ...previewInfo.candidates.filter((candidate) => candidate.shape !== "story"),
          ]
        : previewInfo.candidates;

    for (const candidate of candidates) {
      const signedUrl = urlByPath.get(candidate.path);
      if (signedUrl) {
        previewByContent.set(contentId, {
          url: signedUrl,
          mediaType: previewInfo.mediaType,
          fileName: previewInfo.fileName,
        });
        break;
      }
    }
  }

  return previewByContent;
}

export async function getPlannerContentDetail(contentId: string): Promise<PlannerContentDetail | null> {
  const { supabase, accountId } = await requireAuthContext();

  try {
    const { data, error } = await supabase
      .from("content_items")
      .select(
        "id, platform, placement, scheduled_for, status, auto_generated, prompt_context, campaigns(id, name), content_variants(body, media_ids), publish_jobs(last_error, status, attempt, updated_at, placement, provider_response)"
      )
      .eq("id", contentId)
      .eq("account_id", accountId)
      .maybeSingle<ContentDetailRow>();

    if (error) {
      if (isSchemaMissingError(error)) {
        return null;
      }
      throw error;
    }

    if (!data) return null;

    const detailVariants = normaliseVariants<ContentDetailVariantRow>(data.content_variants);
    const variant = detailVariants[0];
    const mediaIds = variant?.media_ids ?? [];
    const media = await loadMediaPreviews({ supabase, mediaIds, placement: data.placement });

    const jobEntries = Array.isArray(data.publish_jobs)
      ? (data.publish_jobs as ContentPublishJobRow[])
      : data.publish_jobs
      ? [data.publish_jobs as ContentPublishJobRow]
      : [];
    const latestJob = jobEntries
      .filter((row) => Boolean(row.updated_at))
      .sort((a, b) => new Date(b.updated_at ?? 0).getTime() - new Date(a.updated_at ?? 0).getTime())[0];

    return {
      id: data.id,
      platform: data.platform,
      placement: data.placement,
      status: data.status as PlannerItem["status"],
      scheduledFor: data.scheduled_for,
      body: variant?.body ?? "",
      mediaIds,
      campaign: data.campaigns ? { id: data.campaigns.id ?? null, name: data.campaigns.name ?? null } : null,
      autoGenerated: Boolean(data.auto_generated),
      promptContext: (data.prompt_context as Record<string, unknown> | null) ?? null,
      media,
      lastError: latestJob?.last_error ?? null,
      lastAttemptedAt: latestJob?.updated_at ?? null,
      providerResponse: (latestJob?.provider_response as Record<string, unknown> | null) ?? null,
    };
  } catch (error) {
    if (isSchemaMissingError(error)) {
      return null;
    }
    throw error;
  }
}

async function loadMediaPreviews({
  supabase,
  mediaIds,
  placement,
}: {
  supabase: SupabaseClient;
  mediaIds: string[];
  placement: ContentPlacement;
}): Promise<PlannerContentDetail["media"]> {
  if (!mediaIds.length) return [];

  const { data: mediaRows, error } = await supabase
    .from("media_assets")
    .select("id, file_name, media_type, storage_path, derived_variants")
    .in("id", mediaIds)
    .returns<MediaAssetRow[]>();

  if (error) {
    console.error("[planner] failed to load media assets", error);
    return [];
  }

  const rows = mediaRows ?? [];
  if (!rows.length) {
    return [];
  }

  const previewCandidatesById = new Map<string, PreviewCandidate[]>();
  const relativePaths = new Set<string>();

  for (const row of rows) {
    const baseCandidates = resolvePreviewCandidates({
      storagePath: row.storage_path,
      derivedVariants: row.derived_variants ?? {},
    });

    const candidates =
      placement === "story"
        ? [
            ...baseCandidates.filter((candidate) => candidate.shape === "story"),
            ...baseCandidates.filter((candidate) => candidate.shape !== "story"),
          ]
        : baseCandidates;

    previewCandidatesById.set(row.id, candidates);

    for (const candidate of candidates) {
      relativePaths.add(candidate.path);
    }
  }

  const { data: signedUrls, error: signedError } = await supabase.storage
    .from(MEDIA_BUCKET)
    .createSignedUrls(Array.from(relativePaths), 600);

  if (signedError) {
    console.error("[planner] failed to sign media asset urls", signedError);
    return [];
  }

  const urlMap = new Map<string, string>();
  for (const entry of signedUrls ?? []) {
    if (!entry.path) continue;
    if (!entry.error && entry.signedUrl) {
      urlMap.set(entry.path, entry.signedUrl);
    }
  }

  return rows
    .map<PlannerContentDetail["media"][number] | null>((row) => {
      const candidates = previewCandidatesById.get(row.id) ?? [];
      for (const candidate of candidates) {
        const url = urlMap.get(candidate.path);
        if (url) {
          return {
            id: row.id,
            url,
            mediaType: row.media_type,
            fileName: row.file_name ?? null,
          };
        }
      }
      return null;
    })
    .filter((item): item is PlannerContentDetail["media"][number] => Boolean(item));
}

function truncateText(value: string, limit: number) {
  if (value.length <= limit) return value;
  return `${value.slice(0, limit - 1).trim()}â€¦`;
}

export function mapCategoryToLevel(category: string | null): PlannerActivity["level"] {
  if (!category) return "info";
  switch (category) {
    case "publish_failed":
    case "story_publish_failed":
    case "connection_needs_action":
      return "error";
    case "publish_retry":
    case "story_publish_retry":
    case "connection_metadata_updated":
    case "connection_reconnected":
      return "warning";
    default: {
      const lower = category.toLowerCase();
      if (lower.includes("error")) return "error";
      if (lower.includes("warning") || lower.includes("expiring")) {
        return "warning";
      }
      return "info";
    }
  }
}
