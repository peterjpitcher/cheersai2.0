import type { SupabaseClient } from "@supabase/supabase-js";

import { requireAuthContext } from "@/lib/auth/server";
import { MEDIA_BUCKET } from "@/lib/constants";
import { isSchemaMissingError } from "@/lib/supabase/errors";
import { resolvePreviewInfo } from "@/lib/library/data";

interface PlannerItem {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  scheduledFor: string;
  campaignName: string;
  status: "draft" | "scheduled" | "publishing" | "posted" | "failed";
  autoGenerated: boolean;
  mediaPreview?: {
    url: string;
    mediaType: "image" | "video";
  } | null;
}

interface PlannerActivity {
  id: string;
  message: string;
  timestamp: string;
  level: "info" | "warning" | "error";
  category?: string | null;
  metadata?: Record<string, unknown> | null;
  readAt?: string | null;
}

export interface PlannerOverview {
  items: PlannerItem[];
  activity: PlannerActivity[];
}

export interface PlannerContentDetail {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  status: PlannerItem["status"];
  scheduledFor: string | null;
  body: string;
  mediaIds: string[];
  campaign: {
    id: string | null;
    name: string | null;
  } | null;
  autoGenerated: boolean;
  promptContext: Record<string, unknown> | null;
  media: Array<{
    id: string;
    url: string;
    mediaType: "image" | "video";
    fileName: string | null;
  }>;
}

type ContentVariantRow = {
  media_ids: string[] | null;
};

type ContentRow = {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  scheduled_for: string | null;
  status: PlannerItem["status"];
  auto_generated: boolean | null;
  campaigns: {
    name: string | null;
  } | null;
  content_variants: ContentVariantRow[] | ContentVariantRow | null;
};

type ContentDetailVariantRow = {
  body: string | null;
  media_ids: string[] | null;
};

type ContentDetailRow = {
  id: string;
  platform: "facebook" | "instagram" | "gbp";
  scheduled_for: string | null;
  status: PlannerItem["status"];
  auto_generated: boolean | null;
  prompt_context: Record<string, unknown> | null;
  campaigns: {
    id: string | null;
    name: string | null;
  } | null;
  content_variants: ContentDetailVariantRow[] | ContentDetailVariantRow | null;
};

type MediaAssetRow = {
  id: string;
  file_name: string | null;
  media_type: "image" | "video";
  storage_path: string;
};

type NotificationRow = {
  id: string;
  message: string;
  category: string | null;
  metadata: Record<string, unknown> | null;
  read_at: string | null;
  created_at: string;
};

function normaliseVariants<T extends { media_ids: string[] | null }>(
  collection: T[] | T | null | undefined,
): T[] {
  if (!collection) return [];
  return Array.isArray(collection) ? collection : [collection];
}

const EMPTY_OVERVIEW: PlannerOverview = { items: [], activity: [] };

interface PlannerOverviewOptions {
  rangeStart?: Date;
  rangeEnd?: Date;
}

export async function getPlannerOverview(options: PlannerOverviewOptions = {}): Promise<PlannerOverview> {
  const { supabase, accountId } = await requireAuthContext();

  const now = new Date();
  const defaultStart = options.rangeStart ?? now;
  const defaultEnd = options.rangeEnd ?? new Date(defaultStart.getTime() + 7 * 24 * 60 * 60 * 1000);

  const start = defaultStart <= defaultEnd ? defaultStart : defaultEnd;
  const end = defaultEnd >= defaultStart ? defaultEnd : defaultStart;

  const startIso = start.toISOString();
  const endIso = end.toISOString();

  try {
    const { data: contentData, error: contentError } = await supabase
      .from("content_items")
      .select("id, platform, scheduled_for, status, auto_generated, campaigns(name), content_variants(media_ids)")
      .eq("account_id", accountId)
      .gte("scheduled_for", startIso)
      .lte("scheduled_for", endIso)
      .order("scheduled_for", { ascending: true })
      .limit(500)
      .returns<ContentRow[]>();

    if (contentError) {
      if (isSchemaMissingError(contentError)) {
        return EMPTY_OVERVIEW;
      }
      throw contentError;
    }

    const { data: activityData, error: activityError } = await supabase
      .from("notifications")
      .select("id, message, category, metadata, read_at, created_at")
      .eq("account_id", accountId)
      .is("read_at", null)
      .order("created_at", { ascending: false })
      .limit(6)
      .returns<NotificationRow[]>();

    if (activityError) {
      if (isSchemaMissingError(activityError)) {
        return EMPTY_OVERVIEW;
      }
      throw activityError;
    }

    const contentRows = contentData ?? [];
    const activityRows = activityData ?? [];

    const mediaIdByContent = new Map<string, string>();
    const assetIdsToFetch = new Set<string>();

    for (const row of contentRows) {
      const mediaIds = normaliseVariants(row.content_variants).flatMap((variant) => variant.media_ids ?? []);
      const firstMediaId = mediaIds.find((id) => Boolean(id));
      if (firstMediaId) {
        mediaIdByContent.set(row.id, firstMediaId);
        assetIdsToFetch.add(firstMediaId);
      }
    }

    const mediaPreviewByAsset = new Map<string, { url: string; mediaType: "image" | "video" }>();

    if (assetIdsToFetch.size) {
      const { data: assetRows, error: assetError } = await supabase
        .from("media_assets")
        .select("id, media_type, storage_path, derived_variants")
        .in("id", Array.from(assetIdsToFetch));

      if (assetError && !isSchemaMissingError(assetError)) {
        throw assetError;
      }

      const previewPathByAsset = new Map<string, string>();
      const uniquePaths = new Set<string>();

      for (const assetRow of assetRows ?? []) {
        const previewInfo = resolvePreviewInfo({
          storagePath: assetRow.storage_path,
          derivedVariants: assetRow.derived_variants ?? {},
        });

        const pathValue = previewInfo?.path ?? assetRow.storage_path;
        if (pathValue) {
          const normalised = pathValue.startsWith(`${MEDIA_BUCKET}/`)
            ? pathValue.slice(MEDIA_BUCKET.length + 1)
            : pathValue;
          previewPathByAsset.set(assetRow.id, normalised);
          uniquePaths.add(normalised);
        }

        mediaPreviewByAsset.set(assetRow.id, {
          url: "",
          mediaType: assetRow.media_type === "video" ? "video" : "image",
        });
      }

      if (uniquePaths.size) {
        const { data: signedUrls, error: signedError } = await supabase.storage
          .from(MEDIA_BUCKET)
          .createSignedUrls(Array.from(uniquePaths), 600);

        if (signedError) {
          console.error("[planner] failed to sign media previews", signedError);
        } else {
          const urlByPath = new Map<string, string>();
          for (const entry of signedUrls ?? []) {
            if (entry?.path && entry.signedUrl && !entry.error) {
              urlByPath.set(entry.path, entry.signedUrl);
            }
          }

          for (const [assetId, previewPath] of previewPathByAsset.entries()) {
            const preview = mediaPreviewByAsset.get(assetId);
            if (!preview) continue;
            const signedUrl = previewPath ? urlByPath.get(previewPath) : undefined;
            if (signedUrl) {
              mediaPreviewByAsset.set(assetId, { ...preview, url: signedUrl });
            } else {
              mediaPreviewByAsset.delete(assetId);
            }
          }
        }
      }
    }

    const mediaPreviewByContent = new Map<string, { url: string; mediaType: "image" | "video" }>();
    for (const [contentId, assetId] of mediaIdByContent.entries()) {
      const preview = mediaPreviewByAsset.get(assetId);
      if (preview?.url) {
        mediaPreviewByContent.set(contentId, preview);
      }
    }

    const items: PlannerItem[] = contentRows.map((row) => ({
      id: row.id,
      platform: row.platform,
      scheduledFor: row.scheduled_for ?? startIso,
      campaignName: row.campaigns?.name ?? "Untitled campaign",
      status: row.status ?? "draft",
      autoGenerated: Boolean(row.auto_generated),
      mediaPreview: mediaPreviewByContent.get(row.id) ?? null,
    }));

    const activity: PlannerActivity[] = activityRows.map((row) => ({
      id: row.id,
      message: row.message,
      timestamp: row.created_at,
      level: mapCategoryToLevel(row.category),
      category: row.category,
      metadata: row.metadata,
      readAt: row.read_at,
    }));

    return { items, activity };
  } catch (error) {
    if (isSchemaMissingError(error)) {
      return EMPTY_OVERVIEW;
    }
    throw error;
  }
}

export async function getPlannerContentDetail(contentId: string): Promise<PlannerContentDetail | null> {
  const { supabase, accountId } = await requireAuthContext();

  try {
    const { data, error } = await supabase
      .from("content_items")
      .select(
        "id, platform, scheduled_for, status, auto_generated, prompt_context, campaigns(id, name), content_variants(body, media_ids)"
      )
      .eq("id", contentId)
      .eq("account_id", accountId)
      .maybeSingle<ContentDetailRow>();

    if (error) {
      if (isSchemaMissingError(error)) {
        return null;
      }
      throw error;
    }

    if (!data) return null;

    const detailVariants = normaliseVariants<ContentDetailVariantRow>(data.content_variants);
    const variant = detailVariants[0];
    const mediaIds = variant?.media_ids ?? [];
    const media = await loadMediaPreviews({ supabase, mediaIds });

    return {
      id: data.id,
      platform: data.platform,
      status: data.status as PlannerItem["status"],
      scheduledFor: data.scheduled_for,
      body: variant?.body ?? "",
      mediaIds,
      campaign: data.campaigns ? { id: data.campaigns.id ?? null, name: data.campaigns.name ?? null } : null,
      autoGenerated: Boolean(data.auto_generated),
      promptContext: (data.prompt_context as Record<string, unknown> | null) ?? null,
      media,
    };
  } catch (error) {
    if (isSchemaMissingError(error)) {
      return null;
    }
    throw error;
  }
}

async function loadMediaPreviews({
  supabase,
  mediaIds,
}: {
  supabase: SupabaseClient;
  mediaIds: string[];
}): Promise<PlannerContentDetail["media"]> {
  if (!mediaIds.length) return [];

  const { data: mediaRows, error } = await supabase
    .from("media_assets")
    .select("id, file_name, media_type, storage_path")
    .in("id", mediaIds)
    .returns<MediaAssetRow[]>();

  if (error) {
    console.error("[planner] failed to load media assets", error);
    return [];
  }

  const rows = mediaRows ?? [];
  if (!rows.length) {
    return [];
  }

  const relativePaths = Array.from(
    new Set(rows.map((row) => normaliseStoragePath(row.storage_path))),
  );

  const { data: signedUrls, error: signedError } = await supabase.storage
    .from(MEDIA_BUCKET)
    .createSignedUrls(relativePaths, 600);

  if (signedError) {
    console.error("[planner] failed to sign media asset urls", signedError);
    return [];
  }

  const urlMap = new Map<string, string>();
  for (const entry of signedUrls ?? []) {
    if (!entry.path) continue;
    if (!entry.error && entry.signedUrl) {
      urlMap.set(entry.path, entry.signedUrl);
    }
  }

  return rows
    .map<PlannerContentDetail["media"][number] | null>((row) => {
      const path = normaliseStoragePath(row.storage_path);
      const url = urlMap.get(path);
      if (!url) return null;
      return {
        id: row.id,
        url,
        mediaType: row.media_type,
        fileName: row.file_name ?? null,
      };
    })
    .filter((item): item is PlannerContentDetail["media"][number] => Boolean(item));
}

function normaliseStoragePath(path: string) {
  if (path.startsWith(`${MEDIA_BUCKET}/`)) {
    return path.slice(MEDIA_BUCKET.length + 1);
  }
  return path;
}

export function mapCategoryToLevel(category: string | null): PlannerActivity["level"] {
  if (!category) return "info";
  switch (category) {
    case "publish_failed":
    case "connection_needs_action":
      return "error";
    case "publish_retry":
    case "connection_metadata_updated":
    case "connection_reconnected":
      return "warning";
    default: {
      const lower = category.toLowerCase();
      if (lower.includes("error")) return "error";
      if (lower.includes("warning") || lower.includes("expiring")) {
        return "warning";
      }
      return "info";
    }
  }
}
